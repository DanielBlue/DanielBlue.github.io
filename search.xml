<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[华为6.0的WRITE_SETTING权限问题]]></title>
      <url>https://danielblue.github.io/2017/02/18/%E5%8D%8E%E4%B8%BA6-0%E7%9A%84WRITE-SETTING%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>今天在开发中适配华为mate8(6.0)，遇到了注册中申请，并在BaseActivity也手动申请了WRITE_SETTING，依然报权限错误。查了下资料，发现是WRITE_SETTING的权限不能自动授权，也不能运行时请求授权，只能引导用户去开启。</p>
<pre><code>核心代码
//6.0以上才能调用
@TargetApi(23)
void checkPermission(){
    if(!Settings.System.canWrite(this)){
      Intent intent = new Intent(Settings.ACTION_MANAGE_WRITE_SETTINGS,
                Uri.parse(&quot;package:&quot; + getPackageName()));
      startActivityForResult(intent, REQUEST_CODE);
    } 
}
</code></pre><p>在代码中调用checkPermission()，则需要检查当前设备的sdk版本，在低版本上直接调用会报错</p>
<pre><code>if (Build.VERSION.SDK_INT &gt;= 23) {
    checkPermission();
}
</code></pre>]]></content>
      
        
        <tags>
            
            <tag> 6.0权限 </tag>
            
            <tag> WRITE_SETTING </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Vitamio使用问题总结]]></title>
      <url>https://danielblue.github.io/2017/02/18/Vitamio%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h3 id="Vitamio使用问题总结"><a href="#Vitamio使用问题总结" class="headerlink" title="Vitamio使用问题总结"></a>Vitamio使用问题总结</h3><h4 id="1-横竖屏切换-视频不重新加载"><a href="#1-横竖屏切换-视频不重新加载" class="headerlink" title="1.横竖屏切换,视频不重新加载"></a>1.横竖屏切换,视频不重新加载</h4><pre><code>首先要让activity在切屏时不重新走生命周期
在manifest中配置actiovity，android:configChanges=&quot;keyboardHidden|orientation|screenSize&quot;,
然后在Activity中重写onConfigurationChanged()方法。

@Override
public void onConfigurationChanged(Configuration newConfig) {
    super.onConfigurationChanged(newConfig);
    if (CONFIGURATION_TYPE == TYPE_PORTRAIT) {
        //竖屏切横屏逻辑处理            
        turn2Landscape();
    } else if (CONFIGURATION_TYPE == TYPE_LANDSCAPE) {
        //横屏切竖屏逻辑处理
        turn2Portrait();
        }
    }
}
</code></pre><h4 id="2-横竖屏切换-如何使控制器大小随视频的切换而变化"><a href="#2-横竖屏切换-如何使控制器大小随视频的切换而变化" class="headerlink" title="2.横竖屏切换,如何使控制器大小随视频的切换而变化"></a>2.横竖屏切换,如何使控制器大小随视频的切换而变化</h4><pre><code>核心思路:将控制器的view加到一个ViewGroup中来控制大小

在自定义的MediaController构造方法中加入;

RelativeLayout.LayoutParams p = new RelativeLayout.LayoutParams(RelativeLayout.LayoutParams.MATCH_PARENT, RelativeLayout.LayoutParams.MATCH_PARENT);

mRoot.setLayoutParams(p);

 //container就是一个包裹着视频的ViewGroup
 ((RelativeLayout) container).addView(mRoot);
</code></pre><h4 id="3-视频进度跳转逻辑处理"><a href="#3-视频进度跳转逻辑处理" class="headerlink" title="3.视频进度跳转逻辑处理"></a>3.视频进度跳转逻辑处理</h4><pre><code>一般是设置onInfoListener,在缓冲结束时跳转进度

@Override
public boolean onInfo(MediaPlayer mp, int what, int extra) {
    switch (what) {
        case MediaPlayer.MEDIA_INFO_BUFFERING_START:
            //开始缓冲,这里一般暂停播放并显示缓冲百分比等数据
            mp.pause();
            break;
        case MediaPlayer.MEDIA_INFO_BUFFERING_END:
            //缓冲结束，在这里seek到想要跳转到的进度
            mp.start();

            break;
    }
    return false;
}
</code></pre><h5 id="3-1-如果需要在退出时保存进度-或者是home键跳出时保存进度，则一般在Activity的onPause-方法中获取到进度，亲测在onDestory-中获取进度时-播放器已经释放掉了，无法获取到进度。"><a href="#3-1-如果需要在退出时保存进度-或者是home键跳出时保存进度，则一般在Activity的onPause-方法中获取到进度，亲测在onDestory-中获取进度时-播放器已经释放掉了，无法获取到进度。" class="headerlink" title="3.1 如果需要在退出时保存进度,或者是home键跳出时保存进度，则一般在Activity的onPause()方法中获取到进度，亲测在onDestory()中获取进度时,播放器已经释放掉了，无法获取到进度。"></a>3.1 如果需要在退出时保存进度,或者是home键跳出时保存进度，则一般在Activity的onPause()方法中获取到进度，亲测在onDestory()中获取进度时,播放器已经释放掉了，无法获取到进度。</h5><h5 id="3-2-home键退出-又返回的情况下保存进度-需要在onPrepare-中和缓冲结束后都调用seekTo-进行设置进度才可以有效。"><a href="#3-2-home键退出-又返回的情况下保存进度-需要在onPrepare-中和缓冲结束后都调用seekTo-进行设置进度才可以有效。" class="headerlink" title="3.2 home键退出,又返回的情况下保存进度,需要在onPrepare()中和缓冲结束后都调用seekTo(),进行设置进度才可以有效。"></a>3.2 home键退出,又返回的情况下保存进度,需要在onPrepare()中和缓冲结束后都调用seekTo(),进行设置进度才可以有效。</h5>]]></content>
      
        
        <tags>
            
            <tag> Vitamio </tag>
            
            <tag> 视频播放 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RecycleView点击事件错位的问题]]></title>
      <url>https://danielblue.github.io/2017/02/18/RecycleView%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E9%94%99%E4%BD%8D%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>使用RecycleView实现如下的效果</p>
<p><img src="https://github.com/DanielBlue/img/blob/master/listview.gif?raw=true" alt=""></p>
<p>却发现一个问题，无论点击哪一个item，都是第三个item的状态改变，最后发现是因为把点击事件放到了onBindViewHolder()方法中了，每一次点击改变的都会是最后一个item。于是把点击事件放到ViewHolder的构造函数中，问题完美解决</p>
]]></content>
      
        
        <tags>
            
            <tag> RecyclerView </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
