<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[华为6.0的WRITE_SETTING权限问题]]></title>
      <url>https://danielblue.github.io/2017/02/18/%E5%8D%8E%E4%B8%BA6-0%E7%9A%84WRITE-SETTING%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>###今天在开发中适配华为mate8(6.0)，遇到了注册中申请，并在BaseActivity也手动申请了WRITE_SETTING，依然报权限错误。查了下资料，发现是WRITE_SETTING的权限不能自动授权，也不能运行时请求授权，只能引导用户去开启。</p>
<p>###核心代码<br>    //6.0以上才能调用<br>    @TargetApi(23)<br>    void checkPermission(){<br>        if(!Settings.System.canWrite(this)){<br>          Intent intent = new Intent(Settings.ACTION_MANAGE_WRITE_SETTINGS,<br>                    Uri.parse(“package:” + getPackageName()));<br>          startActivityForResult(intent, REQUEST_CODE);<br>        }<br>    }</p>
<p>###在代码中调用checkPermission()，则需要检查当前设备的sdk版本，在低版本上直接调用会报错</p>
<pre><code>if (Build.VERSION.SDK_INT &gt;= 23) {
    checkPermission();
}
</code></pre>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Vitamio使用问题总结]]></title>
      <url>https://danielblue.github.io/2017/02/18/Vitamio%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>###Vitamio使用问题总结</p>
<p>####1.横竖屏切换,视频不重新加载<br>    首先要让activity在切屏时不重新走生命周期<br>    在manifest中配置actiovity，android:configChanges=”keyboardHidden|orientation|screenSize”,<br>    然后在Activity中重写onConfigurationChanged()方法。</p>
<pre><code>@Override
public void onConfigurationChanged(Configuration newConfig) {
    super.onConfigurationChanged(newConfig);
    if (CONFIGURATION_TYPE == TYPE_PORTRAIT) {
        //竖屏切横屏逻辑处理            
        turn2Landscape();
    } else if (CONFIGURATION_TYPE == TYPE_LANDSCAPE) {
        //横屏切竖屏逻辑处理
        turn2Portrait();
        }
    }
}
</code></pre><p>####2.横竖屏切换,如何使控制器大小随视频的切换而变化<br>    核心思路:将控制器的view加到一个ViewGroup中来控制大小</p>
<pre><code>在自定义的MediaController构造方法中加入;

RelativeLayout.LayoutParams p = new RelativeLayout.LayoutParams(RelativeLayout.LayoutParams.MATCH_PARENT, RelativeLayout.LayoutParams.MATCH_PARENT);

mRoot.setLayoutParams(p);

 //container就是一个包裹着视频的ViewGroup
 ((RelativeLayout) container).addView(mRoot);
</code></pre><p>####3.视频进度跳转逻辑处理</p>
<pre><code>一般是设置onInfoListener,在缓冲结束时跳转进度

@Override
public boolean onInfo(MediaPlayer mp, int what, int extra) {
    switch (what) {
        case MediaPlayer.MEDIA_INFO_BUFFERING_START:
            //开始缓冲,这里一般暂停播放并显示缓冲百分比等数据
            mp.pause();
            break;
        case MediaPlayer.MEDIA_INFO_BUFFERING_END:
            //缓冲结束，在这里seek到想要跳转到的进度
            mp.start();

            break;
    }
    return false;
}
</code></pre><p>#####3.1 如果需要在退出时保存进度,或者是home键跳出时保存进度，则一般在Activity的onPause()方法中获取到进度，亲测在onDestory()中获取进度时,播放器已经释放掉了，无法获取到进度。</p>
<p>#####3.2 home键退出,又返回的情况下保存进度,需要在onPrepare()中和缓冲结束后都调用seekTo(),进行设置进度才可以有效。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[RecycleView点击事件错位的问题]]></title>
      <url>https://danielblue.github.io/2017/02/18/RecycleView%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E9%94%99%E4%BD%8D%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>###使用RecycleView实现如下的效果<br><img src="https://github.com/DanielBlue/img/blob/master/listview.gif?raw=true" alt=""></p>
<p>###却发现一个问题，无论点击哪一个item，都是第三个item的状态改变，最后发现是因为把点击事件放到了onBindViewHolder()方法中了，每一次点击改变的都会是最后一个item。于是把点击事件放到ViewHolder的构造函数中，问题完美解决</p>
]]></content>
      
        
    </entry>
    
  
  
</search>
